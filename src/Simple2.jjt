/**
 * JJTree template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */options{  static = true;}PARSER_BEGIN(Simple2)
public class Simple2{  public static void main(String args [])  {    System.out.println("Reading from standard input...");    System.out.print("Enter an expression like \"1+(2+3)*var;\" :");    new Simple2(System.in);    try    {      SimpleNode n = Simple2.Start();      n.dump("");      System.out.println("Thank you.");    }    catch (Exception e)    {      System.out.println("Oops.");      System.out.println(e.getMessage());    }  }}PARSER_END(Simple2)<DEFAULT> SKIP : {
" "
| "\t"
| "\n"
| "\r"
| <"//" (~["\n","\r"])* ("\n" | "\r" | "\r\n")>
| <"/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/">
}

/* reserved words */
<DEFAULT> TOKEN : {
<RELA_OP: ">" | "<" | "<=" | ">=" | "==" | "!=">
| <ADDSUB_OP: "+" | "-">
| <ARITH_OP: "*" | "/" | "<<" | ">>" | ">>>">
| <BITWISE_OP: "&" | "|" | "^">
| <NOT_OP: "!">
| <WHILE: "while">
| <IF: "if">
| <ELSE: "else">
| <ASSIGN: "=">
| <ASPA: "\"">
| <LPAR: "(">
| <RPAR: ")">
| <VIRG: ",">
| <PVIRG: ";">
| <LCHAVETA: "{">
| <RCHAVETA: "}">
| <FUNCTION: "function">
| <MODULE: "module">
| <SIZE: "size">
}

<DEFAULT> TOKEN : {
<INTEGER: (<DIGIT>)+>
| <ID: <LETTER> (<LETTER> | <DIGIT>)*>
| <#LETTER: ["$","A"-"Z","_","a"-"z"]>
| <#DIGIT: ["0"-"9"]>
| <STRING: "\"" (["a"-"z","A"-"Z","0"-"9",":"," ","="])+ "\"">
}

//void Start() : { } { }

/* Gramática , falta alterar algumas pequenas coisas para adaptar a portugues
Module::= <MODULE> <ID> <LCHAVETA> (Declaration)* (Function)* <RCHAVETA>
Declaration::= (ArrayElement | ScalarElement) (<ASSIGN> (("["ArraySize"]") | (<ADDSUB_OP>)? <INTEGER>))? <PVIRG>
Function::= ((<FUNCTION> (ArrayElement | ScalarElement) <ASSIGN> <ID> <LPAR> (Varlist)? <RPAR>) | (<FUNCTION> <ID> <LPAR> (Varlist)? <RPAR>)) <LCHAVETA>Stmtlst<RCHAVETA>  *conflito em FUNCTION
Varlist::= (ArrayElement | ScalarElement) (<VIRG> (ArrayElement| ScalarElement))*
ArrayElement::= <ID> "[" "]"
ScalarElement::= <ID>
Stmtlst::= (Stmt)*
Stmt::= While | If | Assign | Call<PVIRG> *conflito de ID
Assign::= Lhs<ASSIGN>Rhs<PVIRG>
Lhs::= ArrayAccess | ScalarAccess
Rhs::=(Term ((<ARITH_OP> | <BITWISE_OP> | <ADDSUB_OP>) Term)?) | "["ArraySize"]"
ArraySize::= ScalarAccess | <INTEGER>
Term::= (<ADDSUB_OP>)? (<INTEGER> | Call | ArrayAccess | ScalarAccess) * conflito de ID
Exprtest::= <LPAR>Lhs<RELA_OP>Rhs<RPAR>
While::= <WHILE> Exprtest <LCHAVETA> Stmtlst <RCHAVETA>
If::= <IF> Exprtest <LCHAVETA> Stmtlst <RCHAVETA> (<ELSE> <LCHAVETA> Stmtlst <RCHAVETA>)?
Call::=<ID> ("."<ID>)? <LPAR> (ArgumentList)? <RPAR>
ArgumentList::= Argument(<VIRG> Argument)*
Argument::= (<ID> | <STRING> | <INTEGER>)
ArrayAccess::= <ID> "["Index"]"
ScalarAccess::= <ID> ("." <SIZE>)?
Index::= <ID> | <INTEGER>
*/

/* Gramatica simplificada
Module -> a b c DeclarationK FunctionK d.
DeclarationK -> Declaration DeclarationK | .
FunctionK -> Function FunctionK | .
Declaration -> (ArrayElement | ScalarElement) (e ((ArraySize) | (f)? n))? g.
Function -> ((h (ArrayElement | ScalarElement) e b i (Varlist)? j) | (h b i (Varlist)? j)) c Stmtlst d.
Varlist -> (ArrayElement | ScalarElement) KleeneStar1.
KleeneStar1 -> k (ArrayElement | ScalarElement) KleeneStar1 | .
ArrayElement -> b  .
ScalarElement -> b.
Stmtlst -> StmtK.
StmtK -> Stmt StmtK | .
Stmt -> While | If | Assign | Call g.
Assign -> Lhs e Rhs g.
Lhs -> ArrayAccess | ScalarAccess.
Rhs ->(Term ((l | m | f) Term)?) | ArraySize.
ArraySize -> ScalarAccess | n.
Term -> (f)? (n | Call | ArrayAccess | ScalarAccess).
Exprtest -> i Lhs z Rhs j.
While -> x Exprtest c Stmtlst d.
If -> r Exprtest c Stmtlst d (p c Stmtlst d)?.
Call -> b (b)? i (ArgumentList)? j.
ArgumentList -> Argument KleeneStar2.
KleeneStar2 -> k Argument KleeneStar2 | .
Argument -> (b | o | n).
ArrayAccess -> b Index.
ScalarAccess -> b (q)?.
Index -> b | n.

CONFLITOS : Stmt Lhs Term
*/

/*CHECK POINT 1
1.Develop a parser for yal using JavaCC and taking as starting point the yal grammar
furnished (note that the original grammar may originate conflicts when implemented
with parsers of LL(1) type and in that case you need to modify the grammar in order
to eliminate those conflicts);

2. Proceed with the specification of the file jjt to generate , using JJTree, a new
version of the parser including in this case the generation of the syntax tree (the
generated tree should be an AST ), annotating the nodes and leafs of the tree with
the information (including tokens) necessary to perform the subsequent compiler steps ;

3. Include the necessary symbol tables;

4. Semantic Analysis;
*/