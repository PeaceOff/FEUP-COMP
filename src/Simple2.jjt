/**

import java.io.*;
import java.io.FileNotFoundException;
import java.util.*;
 * JJTree template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 * Tabela de simbolos
 * Array? Tamanho
 *
 */options{  static = true;  LOOKAHEAD = 1;  IGNORE_CASE = true;  MULTI = true;  VISITOR = true;}PARSER_BEGIN(Simple2)
import java.io.*;
import java.util.*;

public class Simple2
{  public static void main(String args [])  {    if(args.length < 1){      System.out.println("Pease Feed me with a filename.");      System.exit(1);    }     //Feed me with one file :3    try    {      Simple2 parser = new Simple2(new FileInputStream(args[0]));      SimpleNode n = parser.Start();      n.dump("");      System.out.println("Thank you.");    }catch (FileNotFoundException e){      System.out.println("File Error!");      e.printStackTrace();    }    catch (Exception e)    {      e.printStackTrace();      System.out.println("Oops.");      System.out.println(e.getMessage());    }  }}PARSER_END(Simple2)<DEFAULT> SKIP : {
" "
| "\t"
| "\n"
| "\r"
| <"//" (~["\n","\r"])* ("\n" | "\r" | "\r\n")>
| <"/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/">
}

/* reserved words */
<DEFAULT> TOKEN : {
<RELA_OP: ">" | "<" | "<=" | ">=" | "==" | "!=">
| <ADDSUB_OP: "+" | "-">
| <ARITH_OP: "*" | "/" | "<<" | ">>" | ">>>">
| <BITWISE_OP: "&" | "|" | "^">
| <NOT_OP: "!">
| <WHILE: "while">
| <IF: "if">
| <ELSE: "else">
| <ASSIGN: "=">
| <ASPA: "\"">
| <LPAR: "(">
| <RPAR: ")">
| <VIRG: ",">
| <PVIRG: ";">
| <LCHAVETA: "{">
| <RCHAVETA: "}">
| <FUNCTION: "function">
| <MODULE: "module">
| <SIZE: "size">
}

<DEFAULT> TOKEN : {
<INTEGER: (<DIGIT>)+>
| <ID: <LETTER> (<LETTER> | <DIGIT>)*>
| <#LETTER: ["$","A"-"Z","_","a"-"z"]>
| <#DIGIT: ["0"-"9"]>
| <STRING: "\"" (["a"-"z","A"-"Z","0"-"9",":"," ","="])+ "\"">
}

SimpleNode Start() : { }
{
  Module()
  {return jjtThis;}
}

void Module() : {Token t1;}
{
  <MODULE> t1 = <ID> <LCHAVETA> (Declaration())* (Function())* <RCHAVETA>
  {jjtThis.value = t1.image;}
}

void Declaration() : {} //FIRST: First(ArrayElement, ScalarElement) <ASSIGN> <PVIRG>
{
  (Element()) (<ASSIGN> ( ArrayDeclaration() | NumericDeclaration()))? <PVIRG> // E (= ([100] | -? Integer)   )?  E[] = [100]
}

void NumericDeclaration() : {Token t1, sign;}
{
  ((sign = <ADDSUB_OP>)? t1 = <INTEGER>) //MarkSignal
  {jjtThis.value = t1.image;}
}

void ArrayDeclaration() : {}
{
  ( "[" ArraySize() "]" )
}

void Function() : {Token t1;} //Fisrt FUNCTION!
{
  <FUNCTION> t1 = FunctionDecl() FunctionParameters() <LCHAVETA>Stmtlst()<RCHAVETA> // (ElementArray()? t1=FunctionReturn(t1))?
  {jjtThis.value = t1.image;}
}

Token FunctionDecl() : {Token t1, t2 = null;}
{
t1 = <ID> ( (ElementArray() {/*Mark as array*/})? (t2 = FunctionReturn()))? //Mark as array
  {if(t2 != null){
    jjtThis.value = t1;
    return t2;
  }else{
    jjtThis.value = null;
    return t1;
  }}
}


void FunctionReturnV() : { }
{
	ElementArray() FunctionReturn()
}

Token FunctionReturn()#void : {Token t;}
{
	<ASSIGN> t = <ID>
  {return t;}
}

void FunctionParameters() : { }
{
	<LPAR> (Varlist())? <RPAR>
}

void Varlist()#void : {}
{
  (Element()) (<VIRG> (Element()))*
}

void Element():{Token t1;}
{
  t1 = <ID> (ElementArray() {/*mark as array    */})? //A ou A[]    A->ElementArray
  {jjtThis.value = t1.image;}
}

void ElementArray()#void:{}
{
  "[" "]"
}

void ArrayElement() : {}
{
  <ID> "[" "]"
}

void ScalarElement() : {}
{
  <ID>
}

void Stmtlst() : {}
{
  (Stmt())*
}

void Stmt()#void : {}
{
  While() | If() | AssignCall() <PVIRG> //AssignCall -> Assign() Call() =
}

void AssignOrCall() : {boolean res;}
{
  res = AssignOrCall2() {if(res) return;} Assign2()
}

boolean AssignOrCall2() : {Token t; boolean res;}
{
  t = <ID> res = AssignOrCall3()
  {
    jjtThis.value = t.image;
    return res;
  }
}

boolean AssignOrCall3() : {boolean b = false;}
{
  (ArrayXAccess())  | (Call2() {return true;} ) | ("." (<ID> Call2() {return true;}) | (<SIZE>))?
  {return false;}
}


void AssignCall() : {}
{
  <ID> AssignCall2() // a[1] funcao(2) modulo.funcao() array.size
}

void AssignCall2()#ADefiniteNode(2) : {}  // A.Size = bla   A.func() = bla
{
    (ArrayXAccess()  Assign2())  | Call2() | ("." (<ID> Call2()) | <SIZE> Assign2() )?
}

void Assign2() : {}
{
  <ASSIGN> Rhs() <PVIRG>
}

void Assign() : {}
{
  Lhs() <ASSIGN> Rhs() <PVIRG>
}

void Lhs()#void : {}
{
  ArrayOrScalar()
}

void Rhs()#ADefiniteNode(2) : {Token t1;}
{
  (Term() (( (t1 = <ARITH_OP>) | (t1 = <BITWISE_OP>) | (t1 = <ADDSUB_OP>) ) Term()
            {
              jjtThis.value = t1.image;
            }
          )?)
  | ArrayDeclaration()
}

void ArraySize() : {Token t1;}
{
 (t1 = <ID> ScalarAccess2()) | (t1 = <INTEGER>)
 {jjtThis.value = t1.image;}
}

void Term() : {}
{
  (<ADDSUB_OP>)? (<INTEGER> |  CallArray()) //CallArray -> Call() | ArrayOrScalar()
}

void CallArray() : {}
{
  <ID> CallArray2() //ID.Size
}

void CallArray2() : {}
{
  (ArrayXAccess()) | Call2() | ("." (<ID> Call2()) | <SIZE>)?
}

void Exprtest() : {Token t1;}
{
  <LPAR> Lhs() t1 = <RELA_OP> Rhs() <RPAR>
  {
    jjtThis.value = t1.image;
  }
}

void While() : {}
{
  <WHILE> Exprtest() <LCHAVETA> Stmtlst() <RCHAVETA>
}

void If() : {}
{
  <IF> Exprtest() <LCHAVETA> Stmtlst() <RCHAVETA> (<ELSE> <LCHAVETA> Stmtlst() <RCHAVETA>)?
}

void Call() : {}
{
  <ID> ("." <ID>)? <LPAR> (ArgumentList())? <RPAR>
}

void Call2() : {}
{
  <LPAR> (ArgumentList())? <RPAR>
}

void ArgumentList() : {}
{
  Argument() (<VIRG> Argument())*
}

void Argument() : {Token t1;}
{
  ( (t1 = <ID>) | (t1 = <STRING>) | (t1 = <INTEGER>) )
  {jjtThis.value = t1;}
}

void ArrayOrScalar() : {}
{
  <ID> (ArrayXAccess() | ScalarAccess2())
}

void ArrayXAccess(): {}
{
  "[" Index() "]"
}

void ScalarAccess2(): {}
{
  ("." <SIZE>)?
}

void ScalarAccess() : {}
{
  <ID> ("." <SIZE>)?
}

void Index() : { Token t1;}
{
  (t1 = <ID> #Variable) | ( t1 = <INTEGER>#Constant) { jjtThis.value = t1.image;}
}

/* Gramï¿½tica , falta alterar algumas pequenas coisas para adaptar a portugues
Module::= <MODULE> <ID> <LCHAVETA> (Declaration)* (Function)* <RCHAVETA>
Declaration::= (ArrayElement | ScalarElement) (<ASSIGN> (("["ArraySize"]") | (<ADDSUB_OP>)? <INTEGER>))? <PVIRG>
Function::= ((<FUNCTION> (ArrayElement | ScalarElement) <ASSIGN> <ID> <LPAR> (Varlist)? <RPAR>) | (<FUNCTION> <ID> <LPAR> (Varlist)? <RPAR>)) <LCHAVETA>Stmtlst<RCHAVETA>  *conflito em FUNCTION
Varlist::= (ArrayElement | ScalarElement) (<VIRG> (ArrayElement| ScalarElement))*
ArrayElement::= <ID> "[" "]"
ScalarElement::= <ID>
Stmtlst::= (Stmt)*
Stmt::= While | If | Assign | Call<PVIRG> *conflito de ID
Assign::= Lhs<ASSIGN>Rhs<PVIRG>
Lhs::= ArrayAccess | ScalarAccess
Rhs::=(Term ((<ARITH_OP> | <BITWISE_OP> | <ADDSUB_OP>) Term)?) | "["ArraySize"]"
ArraySize::= ScalarAccess | <INTEGER>
Term::= (<ADDSUB_OP>)? (<INTEGER> | Call | ArrayAccess | ScalarAccess) * conflito de ID
Exprtest::= <LPAR>Lhs<RELA_OP>Rhs<RPAR>
While::= <WHILE> Exprtest <LCHAVETA> Stmtlst <RCHAVETA>
If::= <IF> Exprtest <LCHAVETA> Stmtlst <RCHAVETA> (<ELSE> <LCHAVETA> Stmtlst <RCHAVETA>)?
Call::=<ID> ("."<ID>)? <LPAR> (ArgumentList)? <RPAR>
ArgumentList::= Argument(<VIRG> Argument)*
Argument::= (<ID> | <STRING> | <INTEGER>)
ArrayAccess::= <ID> "["Index"]"
ScalarAccess::= <ID> ("." <SIZE>)?
Index::= <ID> | <INTEGER>


<ID> (ArrayXaccess() | ScalarAccess2())

Lhs::= ArrayOrScalar

ArrayXAccess::= "["Index"]"
ScalarAccess2::= ("." <SIZE>)?

ArrayOrScalar ::= <ID> (ArrayXAccess() | ScalarAccess2())

Assign::= Lhs<ASSIGN>Rhs<PVIRG>
Call::=<ID> ("."<ID>)? <LPAR> (ArgumentList)? <RPAR>


Assign id asdas  =

Simplificar#Cond(res==true) ::= res = Simplificar <ASSIGN> RHS
Simplificar2 ::= (<ID>  Diferenca) return false;

*/

/* Gramatica simplificada
Module -> a b c DeclarationK FunctionK d.
DeclarationK -> Declaration DeclarationK | .
FunctionK -> Function FunctionK | .
Declaration -> (ArrayElement | ScalarElement) (e ((ArraySize) | (f)? n))? g.
Function -> ((h (ArrayElement | ScalarElement) e b i (Varlist)? j) | (h b i (Varlist)? j)) c Stmtlst d.
Varlist -> (ArrayElement | ScalarElement) KleeneStar1.
KleeneStar1 -> k (ArrayElement | ScalarElement) KleeneStar1 | .
ArrayElement -> b  .
ScalarElement -> b.
Stmtlst -> StmtK.
StmtK -> Stmt StmtK | .
Stmt -> While | If | Assign | Call g.
Assign -> Lhs e Rhs g.
Lhs -> ArrayAccess | ScalarAccess.
Rhs ->(Term ((l | m | f) Term)?) | ArraySize.
ArraySize -> ScalarAccess | n.
Term -> (f)? (n | Call | ArrayAccess | ScalarAccess).
Exprtest -> i Lhs z Rhs j.
While -> x Exprtest c Stmtlst d.
If -> r Exprtest c Stmtlst d (p c Stmtlst d)?.
Call -> b (.b)? i (ArgumentList)? j.
ArgumentList -> Argument KleeneStar2.
KleeneStar2 -> k Argument KleeneStar2 | .
Argument -> (b | o | n).
ArrayAccess -> b Index.
ScalarAccess -> b (q)?.
Index -> b | n.

CONFLITOS : Stmt Lhs Term
*/

/*CHECK POINT 1
1.Develop a parser for yal using JavaCC and taking as starting point the yal grammar
furnished (note that the original grammar may originate conflicts when implemented
with parsers of LL(1) type and in that case you need to modify the grammar in order
to eliminate those conflicts);

2. Proceed with the specification of the file jjt to generate , using JJTree, a new
version of the parser including in this case the generation of the syntax tree (the
generated tree should be an AST ), annotating the nodes and leafs of the tree with
the information (including tokens) necessary to perform the subsequent compiler steps ;

3. Include the necessary symbol tables;

4. Semantic Analysis;
*/
